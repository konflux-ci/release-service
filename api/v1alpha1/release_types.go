/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	"time"

	"github.com/konflux-ci/operator-toolkit/conditions"

	"github.com/konflux-ci/release-service/metadata"
	"github.com/konflux-ci/release-service/metrics"
	"k8s.io/apimachinery/pkg/runtime"

	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ReleaseSpec defines the desired state of Release.
type ReleaseSpec struct {
	// Snapshot to be released
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +required
	Snapshot string `json:"snapshot"`

	// ReleasePlan to use for this particular Release
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +required
	ReleasePlan string `json:"releasePlan"`

	// Data is an unstructured key used for providing data for the managed Release Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Data *runtime.RawExtension `json:"data,omitempty"`

	// GracePeriodDays is the number of days a Release should be kept
	// This value is used to define the Release ExpirationTime
	// +optional
	GracePeriodDays int `json:"gracePeriodDays,omitempty"`
}

// ReleaseStatus defines the observed state of Release.
type ReleaseStatus struct {
	// Artifacts is an unstructured key used for storing all the artifacts generated by the managed Release Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Artifacts *runtime.RawExtension `json:"artifacts,omitempty"`

	// Attribution contains information about the entity authorizing the release
	// +optional
	Attribution AttributionInfo `json:"attribution,omitempty"`

	// Collectors is an unstructured key used for storing all the collectors results generated by the Collectors Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Collectors *runtime.RawExtension `json:"collectors,omitempty"`

	// Conditions represent the latest available observations for the release
	// +optional
	Conditions []metav1.Condition `json:"conditions"`

	// CollectorsProcessing contains information about the release collectors processing
	// +optional
	CollectorsProcessing CollectorsInfo `json:"collectorsProcessing,omitempty"`

	// FinalProcessing contains information about the release final processing
	// +optional
	FinalProcessing PipelineInfo `json:"finalProcessing,omitempty"`

	// ManagedProcessing contains information about the release managed processing
	// +optional
	ManagedProcessing PipelineInfo `json:"managedProcessing,omitempty"`

	// TenantProcessing contains information about the release tenant processing
	// +optional
	TenantProcessing PipelineInfo `json:"tenantProcessing,omitempty"`

	// Validation contains information about the release validation
	// +optional
	Validation ValidationInfo `json:"validation,omitempty"`

	// Target references where this release is intended to be released to
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	Target string `json:"target,omitempty"`

	// Automated indicates whether the Release was created as part of an automated process or manually by an end-user
	// +optional
	Automated bool `json:"automated,omitempty"`

	// CompletionTime is the time when a Release was completed
	// +optional
	CompletionTime *metav1.Time `json:"completionTime,omitempty"`

	// StartTime is the time when a Release started
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`

	// ExpirationTime is the time when a Release can be purged
	// +optional
	ExpirationTime *metav1.Time `json:"expirationTime,omitempty"`
}

// AttributionInfo defines the observed state of the release attribution.
type AttributionInfo struct {
	// Author is the username that the release is attributed to
	// +optional
	Author string `json:"author,omitempty"`

	// StandingAuthorization indicates whether the release is attributed through a ReleasePlan
	// +optional
	StandingAuthorization bool `json:"standingAuthorization,omitempty"`
}

// CollectorsInfo defines the observed state of the release collectors.
type CollectorsInfo struct {
	// ManagedCollectorsProcessing contains information about the release managed collectors processing
	ManagedCollectorsProcessing PipelineInfo `json:"managedCollectorsProcessing,omitempty"`

	// TenantCollectorsProcessing contains information about the release tenant collectors processing
	TenantCollectorsProcessing PipelineInfo `json:"tenantCollectorsProcessing,omitempty"`
}

// RoleBindingType defines the state of roleBindings for resource access within the Release pipelineRun.
type RoleBindingType struct {
	// TenantRoleBinding contains the namespaced name of the roleBinding created for accessing resources within the tenant namespace.
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	TenantRoleBinding string `json:"tenantRoleBinding,omitempty"`

	// ManagedRoleBinding contains the namespaced name of the roleBinding created for accessing resources within the managed namespace.
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	ManagedRoleBinding string `json:"managedRoleBinding,omitempty"`

	// SecretRoleBinding contains the namespaced name of the roleBinding created for accessing secrets within the namespace.
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	SecretRoleBinding string `json:"secretRoleBinding,omitempty"`
}

// PipelineInfo defines the observed state of a release pipeline processing.
type PipelineInfo struct {
	// CompletionTime is the time when the Release processing was completed
	// +optional
	CompletionTime *metav1.Time `json:"completionTime,omitempty"`

	// PipelineRun contains the namespaced name of the managed Release PipelineRun executed as part of this release
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	PipelineRun string `json:"pipelineRun,omitempty"`

	// RoleBindings defines the roleBindings for accessing resources during the Release
	// PipelineRun executed as part of this release.
	// +optional
	RoleBindings RoleBindingType `json:"roleBindings,omitempty"`

	// StartTime is the time when the Release processing started
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`
}

// ValidationInfo defines the observed state of the release validation.
type ValidationInfo struct {
	// FailedPostValidation indicates whether the Release was marked as invalid after being initially marked as valid
	FailedPostValidation bool `json:"failedPostValidation,omitempty"`

	// Time is the time when the Release was validated or when the validation state changed
	// +optional
	Time *metav1.Time `json:"time,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=rel
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Snapshot",type=string,JSONPath=`.spec.snapshot`
// +kubebuilder:printcolumn:name="ReleasePlan",type=string,JSONPath=`.spec.releasePlan`
// +kubebuilder:printcolumn:name="Release status",type=string,JSONPath=`.status.conditions[?(@.type=="Released")].reason`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// Release is the Schema for the releases API
type Release struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ReleaseSpec   `json:"spec,omitempty"`
	Status ReleaseStatus `json:"status,omitempty"`
}

// HasFinalPipelineProcessingFinished checks whether the Release Final Pipeline processing has finished, regardless of the result.
func (r *Release) HasFinalPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(finalProcessedConditionType)
}

// HasManagedCollectorsPipelineProcessingFinished checks whether the Release Managed Collectors Pipeline processing has finished, regardless of the result.
func (r *Release) HasManagedCollectorsPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(managedCollectorsProcessedConditionType)
}

// HasManagedPipelineProcessingFinished checks whether the Release Managed Pipeline processing has finished, regardless of the result.
func (r *Release) HasManagedPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(managedProcessedConditionType)
}

// HasTenantCollectorsPipelineProcessingFinished checks whether the Release Tenant Collectors Pipeline processing has finished, regardless of the result.
func (r *Release) HasTenantCollectorsPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(tenantCollectorsProcessedConditionType)
}

// HasTenantPipelineProcessingFinished checks whether the Release Tenant Pipeline processing has finished, regardless of the result.
func (r *Release) HasTenantPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(tenantProcessedConditionType)
}

// HasReleaseFinished checks whether the Release has finished, regardless of the result.
func (r *Release) HasReleaseFinished() bool {
	return r.hasPhaseFinished(releasedConditionType)
}

// IsAttributed checks whether the Release was marked as attributed.
func (r *Release) IsAttributed() bool {
	return r.Status.Attribution.Author != ""
}

// IsAutomated checks whether the Release was marked as automated.
func (r *Release) IsAutomated() bool {
	return r.Status.Automated
}

// IsFinalPipelineProcessedSuccessfully checks whether the Release Final Pipeline was successfully processed.
func (r *Release) IsFinalPipelineProcessedSuccessfully() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, finalProcessedConditionType.String())
}

// IsManagedCollectorsPipelineProcessedSuccessfully checks whether the Release Managed Collectors Pipeline was successfully processed.
func (r *Release) IsManagedCollectorsPipelineProcessedSuccessfully() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, managedCollectorsProcessedConditionType.String())
}

// IsManagedPipelineProcessedSuccessfully checks whether the Release Managed Pipeline was successfully processed.
func (r *Release) IsManagedPipelineProcessedSuccessfully() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, managedProcessedConditionType.String())
}

// IsTenantCollectorsPipelineProcessedSuccessfully checks whether the Release Tenant Collectors Pipeline was successfully processed.
func (r *Release) IsTenantCollectorsPipelineProcessedSuccessfully() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, tenantCollectorsProcessedConditionType.String())
}

// IsTenantPipelineProcessedSuccessfully checks whether the Release Tenant Pipeline was successfully processed.
func (r *Release) IsTenantPipelineProcessedSuccessfully() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, tenantProcessedConditionType.String())
}

// IsFinalPipelineProcessing checks whether the Release Final Pipeline processing is in progress.
func (r *Release) IsFinalPipelineProcessing() bool {
	return r.isPhaseProgressing(finalProcessedConditionType)
}

// IsManagedCollectorsPipelineProcessing checks whether the Release Managed Collectors Pipeline processing is in progress.
func (r *Release) IsManagedCollectorsPipelineProcessing() bool {
	return r.isPhaseProgressing(managedCollectorsProcessedConditionType)
}

// IsManagedPipelineProcessing checks whether the Release Managed Pipeline processing is in progress.
func (r *Release) IsManagedPipelineProcessing() bool {
	return r.isPhaseProgressing(managedProcessedConditionType)
}

// IsTenantCollectorsPipelineProcessing checks whether the Release Tenant Collectors Pipeline processing is in progress.
func (r *Release) IsTenantCollectorsPipelineProcessing() bool {
	return r.isPhaseProgressing(tenantCollectorsProcessedConditionType)
}

// IsTenantPipelineProcessing checks whether the Release Tenant Pipeline processing is in progress.
func (r *Release) IsTenantPipelineProcessing() bool {
	return r.isPhaseProgressing(tenantProcessedConditionType)
}

// IsFinalPipelineSkipped checks whether the Release Final Pipeline processing was skipped.
func (r *Release) IsFinalPipelineSkipped() bool {
	return r.isPhaseSkipped(finalProcessedConditionType)
}

// IsManagedCollectorsPipelineSkipped checks whether the Release Managed Collectors Pipeline was skipped.
func (r *Release) IsManagedCollectorsPipelineSkipped() bool {
	return r.isPhaseSkipped(managedCollectorsProcessedConditionType)
}

// IsManagedPipelineSkipped checks whether the Release Managed Pipeline processing was skipped.
func (r *Release) IsManagedPipelineSkipped() bool {
	return r.isPhaseSkipped(managedProcessedConditionType)
}

// IsTenantCollectorsPipelineSkipped checks whether the Release Tenant Collectors Pipeline was skipped.
func (r *Release) IsTenantCollectorsPipelineSkipped() bool {
	return r.isPhaseSkipped(tenantCollectorsProcessedConditionType)
}

// IsTenantPipelineSkipped checks whether the Release Tenant Pipeline was skipped.
func (r *Release) IsTenantPipelineSkipped() bool {
	return r.isPhaseSkipped(tenantProcessedConditionType)
}

// IsReleased checks whether the Release has finished successfully.
func (r *Release) IsReleased() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, releasedConditionType.String())
}

// IsReleasing checks whether the Release is in progress.
func (r *Release) IsReleasing() bool {
	return r.isPhaseProgressing(releasedConditionType)
}

// IsValid checks whether the Release validation has finished successfully.
func (r *Release) IsValid() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, validatedConditionType.String())
}

// IsFailed checks whether the Release has failed.
func (r *Release) IsFailed() bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, releasedConditionType.String())
	return condition != nil && condition.Status == metav1.ConditionFalse && condition.Reason == FailedReason.String()
}

// MarkFinalPipelineProcessed marks the Release Final Pipeline as processed.
func (r *Release) MarkFinalPipelineProcessed() {
	if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() {
		return
	}

	r.Status.FinalProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.FinalProcessing.StartTime,
		r.Status.FinalProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType.String(),
	)
}

// MarkManagedCollectorsPipelineProcessed marks the Release Managed Collectors Pipeline as processed.
func (r *Release) MarkManagedCollectorsPipelineProcessed() {
	if !r.IsManagedCollectorsPipelineProcessing() || r.HasManagedCollectorsPipelineProcessingFinished() {
		return
	}

	r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.ManagedCollectorsPipelineType.String(),
	)
}

// MarkManagedPipelineProcessed marks the Release Managed Pipeline as processed.
func (r *Release) MarkManagedPipelineProcessed() {
	if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() {
		return
	}

	r.Status.ManagedProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.ManagedProcessing.StartTime,
		r.Status.ManagedProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType.String(),
	)
}

// MarkTenantCollectorsPipelineProcessed marks the Release Tenant Collectors Pipeline as processed.
func (r *Release) MarkTenantCollectorsPipelineProcessed() {
	if !r.IsTenantCollectorsPipelineProcessing() || r.HasTenantCollectorsPipelineProcessingFinished() {
		return
	}

	r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.TenantCollectorsPipelineType.String(),
	)
}

// MarkTenantPipelineProcessed marks the Release Tenant Pipeline as processed.
func (r *Release) MarkTenantPipelineProcessed() {
	if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() {
		return
	}

	r.Status.TenantProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.TenantProcessing.StartTime,
		r.Status.TenantProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType.String(),
	)
}

// MarkFinalPipelineProcessing marks the Release Final Pipeline as processing.
func (r *Release) MarkFinalPipelineProcessing() {
	if r.HasFinalPipelineProcessingFinished() {
		return
	}

	if !r.IsFinalPipelineProcessing() {
		r.Status.FinalProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.StartTime,
		r.Status.FinalProcessing.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType.String(),
	)
}

// MarkManagedCollectorsPipelineProcessing marks the Release Managed Collectors Pipeline as processing.
func (r *Release) MarkManagedCollectorsPipelineProcessing() {
	if r.HasManagedCollectorsPipelineProcessingFinished() {
		return
	}

	if !r.IsManagedCollectorsPipelineProcessing() {
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.StartTime,
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType.String(),
	)
}

// MarkManagedPipelineProcessing marks the Release Managed Pipeline as processing.
func (r *Release) MarkManagedPipelineProcessing() {
	if r.HasManagedPipelineProcessingFinished() {
		return
	}

	if !r.IsManagedPipelineProcessing() {
		r.Status.ManagedProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.StartTime,
		r.Status.ManagedProcessing.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType.String(),
	)
}

// MarkTenantCollectorsPipelineProcessing marks the Release Tenant Collectors Pipeline as processing.
func (r *Release) MarkTenantCollectorsPipelineProcessing() {
	if r.HasTenantCollectorsPipelineProcessingFinished() {
		return
	}

	if !r.IsTenantCollectorsPipelineProcessing() {
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.StartTime,
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.TenantCollectorsPipelineType.String(),
	)
}

// MarkTenantPipelineProcessing marks the Release Tenant Pipeline as processing.
func (r *Release) MarkTenantPipelineProcessing() {
	if r.HasTenantPipelineProcessingFinished() {
		return
	}

	if !r.IsTenantPipelineProcessing() {
		r.Status.TenantProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.StartTime,
		r.Status.TenantProcessing.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType.String(),
	)
}

// MarkFinalPipelineProcessingFailed marks the Release Final Pipeline processing as failed.
func (r *Release) MarkFinalPipelineProcessingFailed(message string) {
	if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() {
		return
	}

	r.Status.FinalProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.FinalProcessing.StartTime,
		r.Status.FinalProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType.String(),
	)
}

// MarkManagedCollectorsPipelineProcessingFailed marks the Release Managed Collectors Pipeline processing as failed.
func (r *Release) MarkManagedCollectorsPipelineProcessingFailed(message string) {
	if !r.IsManagedCollectorsPipelineProcessing() || r.HasManagedCollectorsPipelineProcessingFinished() {
		return
	}

	r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
		r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.ManagedCollectorsPipelineType.String(),
	)
}

// MarkManagedPipelineProcessingFailed marks the Release Managed Pipeline processing as failed.
func (r *Release) MarkManagedPipelineProcessingFailed(message string) {
	if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() {
		return
	}

	r.Status.ManagedProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.ManagedProcessing.StartTime,
		r.Status.ManagedProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType.String(),
	)
}

// MarkTenantCollectorsPipelineProcessingFailed marks the Release Tenant Collectors Pipeline processing as failed.
func (r *Release) MarkTenantCollectorsPipelineProcessingFailed(message string) {
	if !r.IsTenantCollectorsPipelineProcessing() || r.HasTenantCollectorsPipelineProcessingFinished() {
		return
	}

	r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
		r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.TenantCollectorsPipelineType.String(),
	)
}

// MarkTenantPipelineProcessingFailed marks the Release Tenant Pipeline processing as failed.
func (r *Release) MarkTenantPipelineProcessingFailed(message string) {
	if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() {
		return
	}

	r.Status.TenantProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.TenantProcessing.StartTime,
		r.Status.TenantProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType.String(),
	)
}

// MarkFinalPipelineProcessingSkipped marks the Release Final Pipeline processing as skipped.
func (r *Release) MarkFinalPipelineProcessingSkipped() {
	if r.HasFinalPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkManagedCollectorsPipelineProcessingSkipped marks the Release Managed Collectors Pipeline processing as skipped.
func (r *Release) MarkManagedCollectorsPipelineProcessingSkipped() {
	if r.HasManagedCollectorsPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkManagedPipelineProcessingSkipped marks the Release Managed Pipeline processing as skipped.
func (r *Release) MarkManagedPipelineProcessingSkipped() {
	if r.HasManagedPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkTenantCollectorsPipelineProcessingSkipped marks the Release Tenant Collectors Pipeline processing as skipped.
func (r *Release) MarkTenantCollectorsPipelineProcessingSkipped() {
	if r.HasTenantCollectorsPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkTenantPipelineProcessingSkipped marks the Release Tenant Pipeline processing as skipped.
func (r *Release) MarkTenantPipelineProcessingSkipped() {
	if r.HasTenantPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkReleased marks the Release as released.
func (r *Release) MarkReleased() {
	if !r.IsReleasing() || r.HasReleaseFinished() {
		return
	}

	r.Status.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, releasedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedRelease(
		r.Status.StartTime,
		r.Status.CompletionTime,
		r.getPhaseReason(tenantCollectorsProcessedConditionType),
		r.getPhaseReason(tenantProcessedConditionType),
		r.getPhaseReason(managedCollectorsProcessedConditionType),
		r.getPhaseReason(managedProcessedConditionType),
		r.getPhaseReason(finalProcessedConditionType),
		SucceededReason.String(),
		r.Status.Target,
		r.getPhaseReason(validatedConditionType),
	)
}

// MarkReleasing marks the Release as releasing.
func (r *Release) MarkReleasing(message string) {
	if r.HasReleaseFinished() {
		return
	}

	if !r.IsReleasing() {
		r.Status.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetConditionWithMessage(&r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, ProgressingReason, message)

	go metrics.RegisterNewRelease()
}

// MarkReleaseFailed marks the Release as failed.
func (r *Release) MarkReleaseFailed(message string) {
	if !r.IsReleasing() || r.HasReleaseFinished() {
		return
	}

	r.Status.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedRelease(
		r.Status.StartTime,
		r.Status.CompletionTime,
		r.getPhaseReason(tenantCollectorsProcessedConditionType),
		r.getPhaseReason(tenantProcessedConditionType),
		r.getPhaseReason(managedCollectorsProcessedConditionType),
		r.getPhaseReason(managedProcessedConditionType),
		r.getPhaseReason(finalProcessedConditionType),
		FailedReason.String(),
		r.Status.Target,
		r.getPhaseReason(validatedConditionType),
	)
}

// MarkValidated marks the Release as validated.
func (r *Release) MarkValidated() {
	if r.IsValid() {
		return
	}

	r.Status.Validation.Time = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, validatedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterValidatedRelease(
		r.Status.StartTime,
		r.Status.Validation.Time,
		SucceededReason.String(),
		r.Status.Target,
	)
}

// MarkValidationFailed marks the Release validation as failed.
func (r *Release) MarkValidationFailed(message string) {
	if r.IsValid() {
		r.Status.Validation.FailedPostValidation = true
	}

	r.Status.Validation.Time = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, validatedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterValidatedRelease(
		r.Status.StartTime,
		r.Status.Validation.Time,
		FailedReason.String(),
		r.Status.Target,
	)
}

// SetAutomated marks the Release as automated.
func (r *Release) SetAutomated() {
	if r.IsAutomated() {
		return
	}

	r.Status.Automated = true
}

// SetExpirationTime set the time when this release can be purged
func (r *Release) SetExpirationTime(expireDays time.Duration) {
	creationTime := r.CreationTimestamp
	r.Status.ExpirationTime = &metav1.Time{Time: creationTime.Add(time.Hour * 24 * expireDays)}
}

// getPhaseReason returns the current reason for the given ConditionType or empty string if no condition is found.
func (r *Release) getPhaseReason(conditionType conditions.ConditionType) string {
	var reason string

	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())
	if condition != nil {
		reason = condition.Reason
	}

	return reason
}

// hasPhaseFinished checks whether a Release phase (e.g. deployment or processing) has finished.
func (r *Release) hasPhaseFinished(conditionType conditions.ConditionType) bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

	switch {
	case condition == nil:
		return false
	case condition.Status == metav1.ConditionTrue:
		return true
	default:
		return condition.Status == metav1.ConditionFalse && condition.Reason != ProgressingReason.String()
	}
}

// isPhaseProgressing checks whether a Release phase (e.g. deployment or processing) is progressing.
func (r *Release) isPhaseProgressing(conditionType conditions.ConditionType) bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

	switch {
	case condition == nil:
		return false
	case condition.Status == metav1.ConditionTrue:
		return false
	default:
		return condition.Status == metav1.ConditionFalse && condition.Reason == ProgressingReason.String()
	}
}

// isPhaseSkipped checks whether a Release phase was skipped.
func (r *Release) isPhaseSkipped(conditionType conditions.ConditionType) bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())
	return condition != nil && condition.Status == metav1.ConditionTrue && condition.Reason == SkippedReason.String()
}

// +kubebuilder:object:root=true

// ReleaseList contains a list of Release
type ReleaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Release `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Release{}, &ReleaseList{})
}
